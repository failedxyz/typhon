use std::str::FromStr;

use ast;
use common::{Field, Literal, Arg, Type};
use lexer::Tok;

grammar;

pub Program: ast::Program = <decls:TopDecl+> => ast::Program(decls);

TopDecl: ast::TopDecl = {
    "extern" <name:Name> ":" <ty:Type> => ast::TopDecl::Extern(name, ty),
    "fn" <name:Name> "(" <args:Comma<Arg>> ")" ":" <ty:Type> "=" "{{" <stmts:Body<Stmt>> "}}" => ast::TopDecl::Fn(name, args, ty, stmts),
    "struct" <name:Name> ":" "{{" <fields:Body<Field>> "}}" => ast::TopDecl::Struct(name, fields),
};

Field: Field = <name:Name> ":" <ty:Type> => Field(name, ty);

Type: Type = {
    "int" => Type::Int,
    "string" => Type::String,
    "(" <args:Comma<Type>> ")" "->" <ret:Type> => Type::Fn(args, Box::new(ret)),
};

Body<T>: Vec<T> = {
    <f:T?> <stmts:("sep" <T>)*> "sep"? => match f {
        None => stmts,
        Some(s) => {
            let mut stmts = stmts;
            stmts.insert(0, s);
            stmts
        },
    }
};

Stmt: ast::Stmt = {
    <re:"let"?> <name:Name> "=" <expr:Expr> => ast::Stmt::Assign(match re { Some(_) => false, None => true }, name, expr),
    <expr:Expr> => ast::Stmt::Expr(expr),
    "if" <cond:Expr> ":" "{{" <body1:Body<Stmt>> "}}" <body2:("else" ":" "{{" Body<Stmt> "}}")?> => ast::Stmt::If(cond, body1, body2.map(|(_, _, body)| body)),
    "while" <cond:Expr> ":" "{{" <body:Body<Stmt>> "}}" => ast::Stmt::While(cond, body),
    "return" <expr:Expr?> => ast::Stmt::Return(expr),
};

Expr: ast::Expr = DotExpr;

DotExpr: ast::Expr = {
    <left:DotExpr> "." <right:CompExpr> => ast::Expr::Dot(Box::new(left), Box::new(right)),
    <expr:CompExpr> => expr,
};

CompExpr: ast::Expr = {
    <left:CompExpr> "==" <right:ArithExpr> => ast::Expr::Equals(Box::new(left), Box::new(right)),
    <left:CompExpr> "!=" <right:ArithExpr> => ast::Expr::NotEquals(Box::new(left), Box::new(right)),
    <expr:ArithExpr> => expr,
};

ArithExpr: ast::Expr = {
    <left:ArithExpr> "+" <right:FactorExpr> => ast::Expr::Plus(Box::new(left), Box::new(right)),
    <left:ArithExpr> "-" <right:FactorExpr> => ast::Expr::Minus(Box::new(left), Box::new(right)),
    <expr:FactorExpr> => expr,
};

FactorExpr: ast::Expr = {
    <left:FactorExpr> "*" <right:Term> => ast::Expr::Times(Box::new(left), Box::new(right)),
    <expr:Term> => expr,
};

Term: ast::Expr = ExprBottom;

ExprBottom: ast::Expr = {
    <name:Name> "(" <args:Comma<Expr>> ")" => ast::Expr::Call(name, args),
    <literal:Literal> => ast::Expr::Literal(literal),
    <name:Name> => ast::Expr::Name(name),
};

Literal: Literal = {
    <int:LitInt> => Literal::Int(u32::from_str(int).unwrap()),
    <string:LitStr> => Literal::String(string[1..string.len() - 1].to_owned()),
};

Arg: Arg = {
    <name:Name> ":" <ty:Type> => Arg(name, ty),
};

Comma<T>: Vec<T> = {
    <f:T?> <v:("," <T>)*> ","? => match f {
        None => v,
        Some(s) => {
            let mut v = v;
            v.insert(0, s);
            v
        },
    }
};

Name: String = Ident => <>.to_owned();

//

extern {
    type Location = usize;
    type Error = failure::Error;

    enum Tok {
        LitInt => Tok::LitInt(u32), // replace this with int enum later
        LitStr => Tok::LitStr(String),
        Ident => Tok::Ident(String),

        "sep" => Tok::LineSep,
        "{{" => Tok::Indent,
        "}}" => Tok::Dedent,

        "else" => Tok::KwElse,
        "extern" => Tok::KwExtern,
        "fn" => Tok::KwFn,
        "if" => Tok::KwIf,
        "int" => Tok::KwInt,
        "let" => Tok::KwLet,
        "return" => Tok::KwReturn,
        "string" => Tok::KwString,
        "struct" => Tok::KwStruct,
        "while" => Tok::KwWhile,

        ":" => Tok::SymColon,
        "," => Tok::SymComma,
        "." => Tok::SymDot,
        "=" => Tok::SymEqual,
        "(" => Tok::SymLeftParen,
        "-" => Tok::SymMinus,
        "+" => Tok::SymPlus,
        ")" => Tok::SymRightParen,
        "*" => Tok::SymStar,

        "->" => Tok::SymArrow,
        "==" => Tok::SymIsEquals,
        "!=" => Tok::SymNotEquals,
    }
}

