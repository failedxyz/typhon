use std::str::FromStr;

use ast;
use common::{Field, Literal, Arg, Type};

grammar;

pub Program: ast::Program = <decls:TopDecl+> => ast::Program(decls);

TopDecl: ast::TopDecl = {
    "extern" <name:Name> ":" <ty:Type> => ast::TopDecl::Extern(name, ty),
    "fn" <name:Name> "(" <args:Comma<Arg>> ")" ":" <ty:Type> "=" <stmts:Body<Stmt>> "end" => ast::TopDecl::Fn(name, args, ty, stmts),
    "struct" <name:Name> ":" <fields:Body<Field>> "end" => ast::TopDecl::Struct(name, fields),
};

Field: Field = <name:Name> ":" <ty:Type> => Field(name, ty);

Type: Type = {
    "int" => Type::Int,
    "string" => Type::String,
    "(" <args:Comma<Type>> ")" "->" <ret:Type> => Type::Fn(args, Box::new(ret)),
};

Body<T>: Vec<T> = {
    <f:T?> <stmts:(";" <T>)*> ";"? => match f {
        None => stmts,
        Some(s) => {
            let mut stmts = stmts;
            stmts.insert(0, s);
            stmts
        },
    }
};

Stmt: ast::Stmt = {
    <re:"let"?> <name:Name> "=" <expr:Expr> => ast::Stmt::Assign(match re { Some(_) => false, None => true }, name, expr),
    <expr:Expr> => ast::Stmt::Expr(expr),
    "if" <cond:Expr> ":" <body1:Body<Stmt>> <body2:("else" ":" Body<Stmt>)?> "end" => ast::Stmt::If(cond, body1, body2.map(|(_, _, body)| body)),
    "while" <cond:Expr> ":" <body:Body<Stmt>> "end" => ast::Stmt::While(cond, body),
    "return" <expr:Expr?> => ast::Stmt::Return(expr),
};

Expr: ast::Expr = DotExpr;

DotExpr: ast::Expr = {
    <left:DotExpr> "." <right:CompExpr> => ast::Expr::Dot(Box::new(left), Box::new(right)),
    <expr:CompExpr> => expr,
};

CompExpr: ast::Expr = {
    <left:CompExpr> "==" <right:ArithExpr> => ast::Expr::Equals(Box::new(left), Box::new(right)),
    <left:CompExpr> "!=" <right:ArithExpr> => ast::Expr::NotEquals(Box::new(left), Box::new(right)),
    <expr:ArithExpr> => expr,
};

ArithExpr: ast::Expr = {
    <left:ArithExpr> "+" <right:FactorExpr> => ast::Expr::Plus(Box::new(left), Box::new(right)),
    <left:ArithExpr> "-" <right:FactorExpr> => ast::Expr::Minus(Box::new(left), Box::new(right)),
    <expr:FactorExpr> => expr,
};

FactorExpr: ast::Expr = {
    <left:FactorExpr> "*" <right:Term> => ast::Expr::Times(Box::new(left), Box::new(right)),
    <expr:Term> => expr,
};

Term: ast::Expr = ExprBottom;

ExprBottom: ast::Expr = {
    <name:Name> "(" <args:Comma<Expr>> ")" => ast::Expr::Call(name, args),
    <literal:Literal> => ast::Expr::Literal(literal),
    <name:Name> => ast::Expr::Name(name),
};

Literal: Literal = {
    <int:r"[0-9]+"> => Literal::Int(u32::from_str(int).unwrap()),
    <string:r#""[^"]*""#> => Literal::String(string[1..string.len() - 1].to_owned()),
};

Arg: Arg = {
    <name:Name> ":" <ty:Type> => Arg(name, ty),
};

Comma<T>: Vec<T> = {
    <f:T?> <v:("," <T>)*> ","? => match f {
        None => v,
        Some(s) => {
            let mut v = v;
            v.insert(0, s);
            v
        },
    }
};

Name: String = r"[A-Za-z_][A-Za-z0-9_]*" => <>.to_owned();
